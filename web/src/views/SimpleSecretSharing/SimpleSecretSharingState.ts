
import { action, autorun, makeAutoObservable } from "mobx";
import { DiceKeyInFiniteFieldPointFormat, EncodingSpaceOfDiceKeyInFiniteFieldPointFormatYEncodingSpace } from "../../dicekeys/DiceKey/asShamirShare";
import { secretSharingForDiceKeys } from "../../dicekeys/DiceKey/SecretSharingForDiceKeys";
import { NavigationPathState } from "../../state/core/NavigationPathState";
import { ViewState } from "../../state/core/ViewState";
import { DiceKey, DiceKeyWithoutKeyId, FaceLetter, FaceLetters, Number0To24, faceLetterToNumber0to24, number0to24ToFaceLetter } from "../../dicekeys/DiceKey";
import { PseudoRandom } from "../../utilities/pseudorandom";
import { LoadDiceKeyViewState } from "../LoadingDiceKeys/LoadDiceKeyViewState";
import { PrintDiceKeyShareViewPropsWrapper } from "./PrintDiceKeyView";
import { PhysicalMedium, SourceOfDiceKeyShare } from "../../dicekeys/PhysicalMedium";
import { BackupStep, BackupViewState } from "../BackupView/BackupViewState";

const DefaultSecretCenterLetter = 'Z' as const satisfies FaceLetter;

const getRemainingCenterLetters = (usedLettersNowForbidden: Set<FaceLetter> | Iterable<FaceLetter>, startAt: FaceLetter = 'A') => {
	const usedLettersNowForbiddenSet = usedLettersNowForbidden instanceof Set ? usedLettersNowForbidden : new Set(usedLettersNowForbidden);
	const unusedCenterDieFaceLetters = FaceLetters.filter( i => !usedLettersNowForbiddenSet.has(i) );
	const startOrMinus1 = unusedCenterDieFaceLetters.findIndex( fInt => fInt >= startAt );
	return startOrMinus1 === -1 ? unusedCenterDieFaceLetters :
		[...unusedCenterDieFaceLetters.slice(startOrMinus1), ...unusedCenterDieFaceLetters.slice(0, startOrMinus1)];
}



// Step 1: Decide how many shares to generate and how many to recover
//           start with shares hidden
// Step 2: Next, you'll need to create physical copies of the shares as boxes of dice or sheets of paper
//     (print)

// Step 2: Generate or backup share i (if i < k, include generate option)
// Step 3: Backup i
// Step 4: optional test from any k shares
// export interface ShareAsDiceKeyWithSource {
// 	source: SourceOfDiceKeyShare,
// 	diceKey: DiceKey
// }

type SubView = LoadDiceKeyViewState | BackupViewState | PrintDiceKeyShareViewPropsWrapper | undefined;

const SimpleSecretSharingStateName = "SimpleSecretSharingState" as const;
export class SimpleSecretSharingState implements ViewState<typeof SimpleSecretSharingStateName> {
  readonly viewName = SimpleSecretSharingStateName;
  navState: NavigationPathState;

	subView: SubView;
	setSubView = action( (subViewState?: SubView) => {this.subView=subViewState} );
	clearSubView = () => this.setSubView();

	step: number = 0;
	stepNext = action( () => {this.step++} );
	stepPrev = action( () => {this.step--} );

	/**
	 * The minimum number of shares needed to recover the DiceKey.
	 */
	minSharesToDecode: number = 3;
	setMinSharesToDecode = action( (minSharesToDecode: number) => {this.minSharesToDecode=minSharesToDecode} );

	/**
	 * The total number of shares to generate and display in the view.
	 */
	numSharesToDisplay: number = 5;
	setNumSharesToDisplay = action( (numSharesToDisplay: number) => {this.numSharesToDisplay=numSharesToDisplay} );

	/**
	 * The DiceKey to be shared, if the user has specified one.
	 */
	userSpecifiedDiceKeyToBeShared: DiceKey | undefined;

	/**
	 * Random shares generated by the user by rolling new DiceKeys
	 * (ideally with the center die pre-selected.)
	 */
	userScannedHandRandomizedShares: DiceKeyInFiniteFieldPointFormat[] = [];

	/**
	 * For each share (identified by center face letter), a list of physical media
	 * created.
	 */
	physicalMediaCreatedByUserForShare: Partial<Record<FaceLetter, Partial<Record<PhysicalMedium, number>>>> = {};

	startDerivedShareCenterFacesAtLetter: FaceLetter = 'A';
	setStartDerivedShareCenterFacesAtLetter = action( (letter: FaceLetter) => {
		this.startDerivedShareCenterFacesAtLetter = letter;
	});

	secretCenterLetter: FaceLetter = DefaultSecretCenterLetter;

	get userScannedHandRandomizedSharesSorted() {
		return [...this.userScannedHandRandomizedShares].sort( (a, b) => Number(a.x) - Number(b.x) );
	}

	get forbiddenLetters(): FaceLetter[] {
		return [
			...this.diceKeyToSplitIntoShares == null ? [] : [this.diceKeyToSplitIntoShares.centerFace.letter],
			...this.userScannedHandRandomizedShares.map( ({x}) => number0to24ToFaceLetter(Number(x) % 25 as Number0To24) )
		].sort();
	}

	/**
	 * An array of 24 random Y values in the secret sharing space derived from the DiceKey
	 * to be shared. This must be generated with a cryptographically secure pseudo-random
	 * function, which can only be called asynchronously. Until it is generated, the
	 * array will be empty.
	 * 
	 * It is generated and updated by #generate24RandomYValuesForUserSpecifiedDiceKey,
	 * which needs only be run once from this class's constructor..
	 */
	pseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey: bigint[] = [];
	setPseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey = action( (arrayOf24PseudoRandomBigInts: bigint[]) => {
		this.pseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey = arrayOf24PseudoRandomBigInts;
	});

	/**
	 * To be called by the constructor immediate after it calls mobx's makeAutoObservable.
	 * 
	 * To generate 24 random Y values from the dice key to be shared, we need to call
	 * an async function. This should be called every time the DiceKey to be shared changes
	 * (typically never) and fill an array of 24 BigInts.
	 * 
	 * Once that array is filled, all the synchronous calculations that rely on the
	 * pseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey array will automatically update
	 * thanks to mobx and the views can update as well..
	 */
	#generate24RandomYValuesForUserSpecifiedDiceKey = () => {
		autorun( () => {
			const userSpecifiedDiceKeyToSplitIntoShares = this.userSpecifiedDiceKeyToBeShared;
			if (userSpecifiedDiceKeyToSplitIntoShares == null) {
				this.setPseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey([]);
			} else {
				PseudoRandom.createFromStringSeed(`dicekey shares for ${userSpecifiedDiceKeyToSplitIntoShares.inHumanReadableForm}`).then(
					pRandom => pRandom.getUInts256(24, EncodingSpaceOfDiceKeyInFiniteFieldPointFormatYEncodingSpace).then( random24YValuesFromUserSpecifiedDiceKey =>
						this.setPseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey(random24YValuesFromUserSpecifiedDiceKey)
					)
				)
			}
		});
	}
	
	get diceKeyToBeSharedAsFiniteFieldPoint(): DiceKeyInFiniteFieldPointFormat | undefined {
		if (this.userSpecifiedDiceKeyToBeShared != null) {
			return this.userSpecifiedDiceKeyToBeShared.asShamirShareFiniteFieldPoint;
		}
		if (this.userScannedHandRandomizedSharesSorted.length >= this.minSharesToDecode) {
			secretSharingForDiceKeys.recoverDiceKeyInFiniteFieldPointFormat(this.secretCenterLetter, this.userScannedHandRandomizedSharesSorted, this.minSharesToDecode);
		}
		return;
	}

	get diceKeyToSplitIntoShares(): DiceKey | undefined {
		if (this.userSpecifiedDiceKeyToBeShared != null) {
			return this.userSpecifiedDiceKeyToBeShared;
		} else if (this.diceKeyToBeSharedAsFiniteFieldPoint != null) {
			return DiceKeyWithoutKeyId.fromFiniteFieldPointForShamirSharing(this.diceKeyToBeSharedAsFiniteFieldPoint);
		}
		return;
	}

	/**
	 * If the user HAS NOT provided a DiceKey (secret) to split into share, use minSharesToDecode total shares
	 * (combining any userProvidedShares with pseudoRandomShares) to define the secret (DiceKey) to be shared.
	 * and the next share (minSharesToDecode) will complete the minimal set of shares needed to decode the secret.
	 * 
	 * If the user HAS provided a DiceKey (secret) to split into shares, use minSharesToDecode - 1 total shares
	 * (combining any userProvidedShares with pseudoRandomShares) to define the secret (DiceKey) to be shared.
	 */
	get pseudoRandomShares() {
		const numberOfUserDefinedShares = this.userScannedHandRandomizedShares.length + ( this.userSpecifiedDiceKeyToBeShared == null ? 0 : 1 );
		const numSharesToGenerate = Math.min(
			this.minSharesToDecode - numberOfUserDefinedShares,
			this.pseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey.length
		);
		if (numSharesToGenerate <= 0) return [];
		const lettersAlreadyUsed = [
				...(this.diceKeyToSplitIntoShares == null ? [] : [this.diceKeyToSplitIntoShares.centerFace.letter]),
				...this.userScannedHandRandomizedShares.map( ({x}) => number0to24ToFaceLetter(Number(x) % 25 as Number0To24) )
			];
		return getRemainingCenterLetters(lettersAlreadyUsed, this.startDerivedShareCenterFacesAtLetter)
			.slice(0, numSharesToGenerate)
			.map( (letter, i) => ({
					x: BigInt(faceLetterToNumber0to24(letter)),
					y: this.pseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey[i]!,
				} satisfies DiceKeyInFiniteFieldPointFormat)
			);
	}

	/**
	 * The redundant shares (those beyond minSharesToDecode) that do not
	 * define the secret in our calculations but can be used to re-derive it
	 * if other shares are missing.
	 */
	get derivedRedundantShares(): DiceKeyInFiniteFieldPointFormat[] {
		const numRedundantSharesNeeded = this.numSharesToDisplay - (this.minSharesToDecode - (this.userSpecifiedDiceKeyToBeShared == null ? 0 : 1));
		// These shares define the secret and are sufficient to decode it
		const userDefinedPoints = [
			...(this.userSpecifiedDiceKeyToBeShared == null ? [] : [this.userSpecifiedDiceKeyToBeShared.asShamirShareFiniteFieldPoint]),
			...this.userScannedHandRandomizedSharesSorted,
		];
		const definingPoints = [
			...userDefinedPoints,
			...this.pseudoRandomShares
		];
		if (definingPoints.length < this.minSharesToDecode) return [];
		const derivedShareCenterLetters = getRemainingCenterLetters(
			definingPoints.map( ({x}) => number0to24ToFaceLetter(Number(x) % 25 as Number0To24) ),
			this.startDerivedShareCenterFacesAtLetter
		).slice(0, numRedundantSharesNeeded);
		return secretSharingForDiceKeys.generateSharesForLetters(
			definingPoints,
			derivedShareCenterLetters,
			this.minSharesToDecode
		);
	}

	get generatedShares() {
		return [
			...this.pseudoRandomShares,
			...this.derivedRedundantShares
		];
	}

	get sharesAsDiceKeysWithSource(): {
		source: SourceOfDiceKeyShare,
		diceKey: DiceKey
	}[] {
		return [
			...this.userScannedHandRandomizedSharesSorted.map( share => ({source: "scanned" as const, share}) ),
			...this.pseudoRandomShares.map( share => ({source: "pseudorandom" as const, share}) ),
			...this.derivedRedundantShares.map( share => ({source: "calculated" as const, share}) )
		].map( ({source, share}) => {
			const diceKey = DiceKeyWithoutKeyId.fromFiniteFieldPointForShamirSharing(share);
			return {
				source, diceKey
			}
		});
	}

	addUserScannedHandRandomizedShare = action( (diceKeyAsFiniteFieldPoint: DiceKeyInFiniteFieldPointFormat) => {
		this.userScannedHandRandomizedShares = [
			...this.userScannedHandRandomizedShares.filter( s => s.x !== diceKeyAsFiniteFieldPoint.x ),
			diceKeyAsFiniteFieldPoint
		].sort( (a, b) => Number(a.x) - Number(b.x) );
	});

	removeUserScannedHandRandomizedShare = action( (centerLetter: FaceLetter) => {
		const x = BigInt(faceLetterToNumber0to24(centerLetter));
		this.userScannedHandRandomizedShares = this.userScannedHandRandomizedShares.filter( s => s.x !== x );
	});

	addPhysicalMediaCreatedByUserForShare = action( (centerLetter: FaceLetter, physicalMedium: PhysicalMedium) => {
		this.physicalMediaCreatedByUserForShare[centerLetter] = {
			...(this.physicalMediaCreatedByUserForShare[centerLetter] ?? {}),
			[physicalMedium]: (this.physicalMediaCreatedByUserForShare[centerLetter]?.[physicalMedium] ?? 0) + 1 
		};
	});


	onShareAsDiceKeyLoadCompletedOrCancelled = (diceKey: DiceKey | undefined) => {
		this.clearSubView();
		if (diceKey == null) return;
		if (diceKey.centerFace.letter === this.userSpecifiedDiceKeyToBeShared?.centerFace.letter) {
			// FIXME -- show error message
			return;
		}
		this.addUserScannedHandRandomizedShare(diceKey.asShamirShareFiniteFieldPoint);
	}

	loadShareAsDiceKey = action( () => {
		this.subView = new LoadDiceKeyViewState(this.navState);
	})


	initiatePrintViewHandler = (
		share: DiceKey | undefined = this.sharesAsDiceKeysWithSource.find( p => p.source !== "scanned")?.diceKey
	) => () => {
		if (share == null || this.diceKeyToSplitIntoShares == null) return;
		const toRecoverDiceKeyWithCenterLetter = this.diceKeyToSplitIntoShares.centerFace.letter;
		const otherShareLetters = this.sharesAsDiceKeysWithSource.map( p => p.diceKey.centerFace.letter).filter( l => l !== share.centerFace.letter);
		this.setSubView(new PrintDiceKeyShareViewPropsWrapper({
			share, minSharesToDecode: this.minSharesToDecode, toRecoverDiceKeyWithCenterLetter, otherShareLetters,
			onComplete: (status) => {
				this.clearSubView();
				if (status === "printed") {
					this.addPhysicalMediaCreatedByUserForShare(share.centerFace.letter, PhysicalMedium.printout);
				}
			}
		}));
	}
	
	initiateCopyToPhysicalMediumHandler = (diceKey: DiceKey, physicalMedium: PhysicalMedium) => () => {
		this.setSubView(new BackupViewState(
			this.navState,
			{diceKey},
			BackupStep.Introduction,
			physicalMedium));
	}


  constructor(
    parentNavState: NavigationPathState,
		{
			userSpecifiedDiceKeyToBeShared,
			// minSharesToDecode = 2,
			// numSharesToDisplay = 3,
			// step = 0,
			...initialSettings
		} : {
			userSpecifiedDiceKeyToBeShared?: DiceKey,
			// minSharesToDecode?: number,
			// numSharesToDisplay?: number,
			// step: number;
		} & Partial<SimpleSecretSharingState>
  ) {
		this.userSpecifiedDiceKeyToBeShared = userSpecifiedDiceKeyToBeShared;
		Object.assign(this, initialSettings);
    this.navState = new NavigationPathState(parentNavState, SimpleSecretSharingStateName, () => "");
		// this.minSharesToDecode = minSharesToDecode;
		// this.numSharesToDisplay = numSharesToDisplay;
		// this.step=step;
    makeAutoObservable(this);
		this.#generate24RandomYValuesForUserSpecifiedDiceKey();
  }
}

// Should deterministic shares been generated via a pseudo-random number generator seeded by the secret?