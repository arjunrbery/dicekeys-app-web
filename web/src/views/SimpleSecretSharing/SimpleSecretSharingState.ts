
import { action, autorun, makeAutoObservable } from "mobx";
import { DiceKeyInFiniteFieldPointFormat, EncodingSpaceOfDiceKeyInFiniteFieldPointFormatYEncodingSpace } from "../../dicekeys/DiceKey/asShamirShare";
import { secretSharingForDiceKeys } from "../../dicekeys/DiceKey/SecretSharingForDiceKeys";
import { NavigationPathState } from "../../state/core/NavigationPathState";
import { ViewState } from "../../state/core/ViewState";
import { DiceKey, DiceKeyWithoutKeyId, FaceLetter, FaceLetters, Number0To24, faceLetterToNumber0to24, number0to24ToFaceLetter } from "../../dicekeys/DiceKey";
import { PseudoRandom } from "../../utilities/pseudorandom";
import { LoadDiceKeyViewState } from "../LoadingDiceKeys/LoadDiceKeyViewState";
import { PrintDiceKeyShareViewPropsWrapper } from "./PrintDiceKeyView";
import { HandGeneratedBackupMedium, MachineGeneratedBackupMediumPrintout, PhysicalBackupMedium, SourceOfDiceKeyShare } from "../../dicekeys/PhysicalMedium";
import { CopyToPhysicalMediumWizardState } from "../../views/BackupView/CopyToPhysicalMediumWizardState";

export enum SimpleSecretSharingSteps {
	ChooseMinAndTotalNumberOfShares = 0,
	ReplaceWithRandom,
	CopyToPhysicalMedium,
	END_EXCLUSIVE,
	END_INCLUSIVE = END_EXCLUSIVE - 1,
	// eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
	START_INCLUSIVE = 0,
}

const DefaultSecretCenterLetter = 'Z' as const satisfies FaceLetter;

const getRemainingCenterLetters = (usedLettersNowForbidden: Set<FaceLetter> | Iterable<FaceLetter>, startAt: FaceLetter = 'A') => {
	const usedLettersNowForbiddenSet = usedLettersNowForbidden instanceof Set ? usedLettersNowForbidden : new Set(usedLettersNowForbidden);
	const unusedCenterDieFaceLetters = FaceLetters.filter( i => !usedLettersNowForbiddenSet.has(i) );
	const startOrMinus1 = unusedCenterDieFaceLetters.findIndex( fInt => fInt >= startAt );
	return startOrMinus1 === -1 ? unusedCenterDieFaceLetters :
		[...unusedCenterDieFaceLetters.slice(startOrMinus1), ...unusedCenterDieFaceLetters.slice(0, startOrMinus1)];
}


type SubView = LoadDiceKeyViewState | CopyToPhysicalMediumWizardState | PrintDiceKeyShareViewPropsWrapper | undefined;

const SimpleSecretSharingStateName = "SimpleSecretSharingState" as const;
export class SimpleSecretSharingState implements ViewState {
  readonly viewName = SimpleSecretSharingStateName;
  navState: NavigationPathState;

	subView: SubView;
	setSubView = action( (subViewState?: SubView) => {this.subView=subViewState} );
	clearSubView = () => this.setSubView();

	step: number = 0;
	
	get stepPrev() { return this.step <= SimpleSecretSharingSteps.START_INCLUSIVE ? undefined : action( () => this.step--) }
	get stepNext() { return this.step < SimpleSecretSharingSteps.END_INCLUSIVE && this.isStepComplete(this.step) ? action( () => this.step++) : undefined }

	isStepComplete = (step: SimpleSecretSharingSteps): boolean => {
		switch (step) {
			case SimpleSecretSharingSteps.CopyToPhysicalMedium:
				return this.sharesToBackup.length === 0;
			default: return true;
		}
	}
	/**
	 * The minimum number of shares needed to recover the DiceKey.
	 */
	minSharesToDecode: number = 3;
	setMinSharesToDecode = action( (minSharesToDecode: number) => {this.minSharesToDecode=minSharesToDecode} );

	/**
	 * The total number of shares to generate and display in the view.
	 */
	numSharesToDisplay: number = 5;
	setNumSharesToDisplay = action( (numSharesToDisplay: number) => {this.numSharesToDisplay=numSharesToDisplay} );

	/**
	 * The DiceKey to be shared, if the user has specified one.
	 */
	getUserSpecifiedDiceKeyToBeShared: () => DiceKey | undefined;
	setUserSpecifiedDiceKeyToBeShared?: (diceKey: DiceKey | undefined) => void;
	get userSpecifiedDiceKeyToBeShared(): DiceKey | undefined { return this.getUserSpecifiedDiceKeyToBeShared(); }

	/**
	 * Random shares generated by the user by rolling new DiceKeys
	 * (ideally with the center die pre-selected.)
	 */
	userScannedHandRandomizedShares: DiceKeyInFiniteFieldPointFormat[] = [];

	/**
	 * For each share (identified by center face letter), a list of physical media
	 * created.
	 */
	physicalMediaCreatedByUserForShare: Partial<Record<FaceLetter, Partial<Record<PhysicalBackupMedium, number>>>> = {};

	startDerivedShareCenterFacesAtLetter: FaceLetter = 'A';
	setStartDerivedShareCenterFacesAtLetter = action( (letter: FaceLetter) => {
		this.startDerivedShareCenterFacesAtLetter = letter;
	});

	secretCenterLetter: FaceLetter = DefaultSecretCenterLetter;

	get userScannedHandRandomizedSharesSorted() {
		return [...this.userScannedHandRandomizedShares].sort( (a, b) => Number(a.x) - Number(b.x) );
	}

	get forbiddenLetters(): FaceLetter[] {
		return [
			...this.diceKeyToSplitIntoShares == null ? [] : [this.diceKeyToSplitIntoShares.centerFace.letter],
			...this.userScannedHandRandomizedShares.map( ({x}) => number0to24ToFaceLetter(Number(x) % 25 as Number0To24) )
		].sort();
	}

	/**
	 * An array of 24 random Y values in the secret sharing space derived from the DiceKey
	 * to be shared. This must be generated with a cryptographically secure pseudo-random
	 * function, which can only be called asynchronously. Until it is generated, the
	 * array will be empty.
	 * 
	 * It is generated and updated by #generate24RandomYValuesForUserSpecifiedDiceKey,
	 * which needs only be run once from this class's constructor..
	 */
	pseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey: bigint[] = [];
	setPseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey = action( (arrayOf24PseudoRandomBigInts: bigint[]) => {
		this.pseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey = arrayOf24PseudoRandomBigInts;
	});

	/**
	 * To be called by the constructor immediate after it calls mobx's makeAutoObservable.
	 * 
	 * To generate 24 random Y values from the dice key to be shared, we need to call
	 * an async function. This should be called every time the DiceKey to be shared changes
	 * (typically never) and fill an array of 24 BigInts.
	 * 
	 * Once that array is filled, all the synchronous calculations that rely on the
	 * pseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey array will automatically update
	 * thanks to mobx and the views can update as well..
	 */
	#generate24RandomYValuesForUserSpecifiedDiceKey = () => {
		autorun( () => {
			const userSpecifiedDiceKeyToSplitIntoShares = this.userSpecifiedDiceKeyToBeShared;
			if (userSpecifiedDiceKeyToSplitIntoShares == null) {
				this.setPseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey([]);
			} else {
				PseudoRandom.createFromStringSeed(`dicekey shares for ${userSpecifiedDiceKeyToSplitIntoShares.inHumanReadableForm}`).then(
					pRandom => pRandom.getUInts256(24, EncodingSpaceOfDiceKeyInFiniteFieldPointFormatYEncodingSpace).then( random24YValuesFromUserSpecifiedDiceKey =>
						this.setPseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey(random24YValuesFromUserSpecifiedDiceKey)
					)
				)
			}
		});
	}
	
	get diceKeyToBeSharedAsFiniteFieldPoint(): DiceKeyInFiniteFieldPointFormat | undefined {
		if (this.userSpecifiedDiceKeyToBeShared != null) {
			return this.userSpecifiedDiceKeyToBeShared.asShamirShareFiniteFieldPoint;
		}
		if (this.userScannedHandRandomizedSharesSorted.length >= this.minSharesToDecode) {
			secretSharingForDiceKeys.recoverDiceKeyInFiniteFieldPointFormat(this.secretCenterLetter, this.userScannedHandRandomizedSharesSorted, this.minSharesToDecode);
		}
		return;
	}

	get diceKeyToSplitIntoShares(): DiceKey | undefined {
		if (this.userSpecifiedDiceKeyToBeShared != null) {
			return this.userSpecifiedDiceKeyToBeShared;
		} else if (this.diceKeyToBeSharedAsFiniteFieldPoint != null) {
			return DiceKeyWithoutKeyId.fromFiniteFieldPointForShamirSharing(this.diceKeyToBeSharedAsFiniteFieldPoint);
		}
		return;
	}

	/**
	 * If the user HAS NOT provided a DiceKey (secret) to split into share, use minSharesToDecode total shares
	 * (combining any userProvidedShares with pseudoRandomShares) to define the secret (DiceKey) to be shared.
	 * and the next share (minSharesToDecode) will complete the minimal set of shares needed to decode the secret.
	 * 
	 * If the user HAS provided a DiceKey (secret) to split into shares, use minSharesToDecode - 1 total shares
	 * (combining any userProvidedShares with pseudoRandomShares) to define the secret (DiceKey) to be shared.
	 */
	get pseudoRandomShares() {
		const numberOfUserDefinedShares = this.userScannedHandRandomizedShares.length + ( this.userSpecifiedDiceKeyToBeShared == null ? 0 : 1 );
		const numSharesToGenerate = Math.min(
			this.minSharesToDecode - numberOfUserDefinedShares,
			this.pseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey.length
		);
		if (numSharesToGenerate <= 0) return [];
		const lettersAlreadyUsed = [
				...(this.diceKeyToSplitIntoShares == null ? [] : [this.diceKeyToSplitIntoShares.centerFace.letter]),
				...this.userScannedHandRandomizedShares.map( ({x}) => number0to24ToFaceLetter(Number(x) % 25 as Number0To24) )
			];
		return getRemainingCenterLetters(lettersAlreadyUsed, this.startDerivedShareCenterFacesAtLetter)
			.slice(0, numSharesToGenerate)
			.map( (letter, i) => ({
					x: BigInt(faceLetterToNumber0to24(letter)),
					y: this.pseudoRandom24YValuesDerivedFromUserSpecifiedDiceKey[i]!,
				} satisfies DiceKeyInFiniteFieldPointFormat)
			);
	}

	/**
	 * The redundant shares (those beyond minSharesToDecode) that do not
	 * define the secret in our calculations but can be used to re-derive it
	 * if other shares are missing.
	 */
	get derivedRedundantShares(): DiceKeyInFiniteFieldPointFormat[] {
		const numRedundantSharesNeeded = this.numSharesToDisplay - (this.minSharesToDecode - (this.userSpecifiedDiceKeyToBeShared == null ? 0 : 1));
		// These shares define the secret and are sufficient to decode it
		const userDefinedPoints = [
			...(this.userSpecifiedDiceKeyToBeShared == null ? [] : [this.userSpecifiedDiceKeyToBeShared.asShamirShareFiniteFieldPoint]),
			...this.userScannedHandRandomizedSharesSorted,
		];
		const definingPoints = [
			...userDefinedPoints,
			...this.pseudoRandomShares
		];
		if (definingPoints.length < this.minSharesToDecode) return [];
		const derivedShareCenterLetters = getRemainingCenterLetters(
			definingPoints.map( ({x}) => number0to24ToFaceLetter(Number(x) % 25 as Number0To24) ),
			this.startDerivedShareCenterFacesAtLetter
		).slice(0, numRedundantSharesNeeded);
		return secretSharingForDiceKeys.generateSharesForLetters(
			definingPoints,
			derivedShareCenterLetters,
			this.minSharesToDecode
		);
	}

	get generatedShares() {
		return [
			...this.pseudoRandomShares,
			...this.derivedRedundantShares
		];
	}

	get sharesAsDiceKeysWithSource(): {
		source: SourceOfDiceKeyShare,
		diceKey: DiceKey
	}[] {
		return [
			...this.userScannedHandRandomizedSharesSorted.map( share => ({source: "scanned" as const, share}) ),
			...this.pseudoRandomShares.map( share => ({source: "pseudorandom" as const, share}) ),
			...this.derivedRedundantShares.map( share => ({source: "calculated" as const, share}) )
		].map( ({source, share}) => {
			const diceKey = DiceKeyWithoutKeyId.fromFiniteFieldPointForShamirSharing(share);
			return {
				source, diceKey
			}
		});
	}

	get sharesToBackup() { return this.sharesAsDiceKeysWithSource.filter(
			p => p.source !== "scanned" &&
			Object.keys(this.physicalMediaCreatedByUserForShare[p.diceKey.centerFace.letter] ?? {}).length === 0
		).map( p => p.diceKey );
	}

	addUserScannedHandRandomizedShare = action( (diceKeyAsFiniteFieldPoint: DiceKeyInFiniteFieldPointFormat) => {
		this.userScannedHandRandomizedShares = [
			...this.userScannedHandRandomizedShares.filter( s => s.x !== diceKeyAsFiniteFieldPoint.x ),
			diceKeyAsFiniteFieldPoint
		].sort( (a, b) => Number(a.x) - Number(b.x) );
	});

	removeUserScannedHandRandomizedShare = action( (centerLetter: FaceLetter) => {
		const x = BigInt(faceLetterToNumber0to24(centerLetter));
		this.userScannedHandRandomizedShares = this.userScannedHandRandomizedShares.filter( s => s.x !== x );
	});

	addPhysicalMediaCreatedByUserForShare = action( (centerLetter: FaceLetter, physicalMedium: PhysicalBackupMedium) => {
		this.physicalMediaCreatedByUserForShare[centerLetter] = {
			...(this.physicalMediaCreatedByUserForShare[centerLetter] ?? {}),
			[physicalMedium]: (this.physicalMediaCreatedByUserForShare[centerLetter]?.[physicalMedium] ?? 0) + 1 
		};
	});


	onShareAsDiceKeyLoadCompletedOrCancelled = (result: {diceKey: DiceKey} | undefined) => {
		const diceKey = result?.diceKey;
		this.clearSubView();
		if (diceKey == null) return;
		if (diceKey.centerFace.letter === this.userSpecifiedDiceKeyToBeShared?.centerFace.letter) {
			// FIXME -- show error message
			return;
		}
		this.addUserScannedHandRandomizedShare(diceKey.asShamirShareFiniteFieldPoint);
	}

	loadShareAsDiceKey = action( () => {
		this.subView = new LoadDiceKeyViewState(this.navState);
	})


	initiatePrintViewHandler = (
		share: DiceKey | undefined = this.sharesAsDiceKeysWithSource.find( p => p.source !== "scanned")?.diceKey
	) => () => {
		if (share == null || this.diceKeyToSplitIntoShares == null) return;
		const toRecoverDiceKeyWithCenterLetter = this.diceKeyToSplitIntoShares.centerFace.letter;
		const otherShareLetters = this.sharesAsDiceKeysWithSource.map( p => p.diceKey.centerFace.letter).filter( l => l !== share.centerFace.letter);
		this.setSubView(new PrintDiceKeyShareViewPropsWrapper({
			share, minSharesToDecode: this.minSharesToDecode, toRecoverDiceKeyWithCenterLetter, otherShareLetters,
			onComplete: (status) => {
				this.clearSubView();
				if (status !== "cancelled") {
					this.addPhysicalMediaCreatedByUserForShare(share.centerFace.letter, MachineGeneratedBackupMediumPrintout);
				}
			}
		}));
	}
	
	initiateCopyToPhysicalMediumHandler = (getSetDiceKey: {
		getDiceKey: () => DiceKey | undefined, setDiceKey?: (diceKey: DiceKey | undefined) => void},
		medium: HandGeneratedBackupMedium) => () => {
		this.setSubView(new CopyToPhysicalMediumWizardState(
			this.navState, medium, {...getSetDiceKey}));
	}


  constructor(
    parentNavState: NavigationPathState,
		{
			getUserSpecifiedDiceKeyToBeShared = () => undefined,
			setUserSpecifiedDiceKeyToBeShared,
			...initialSettings
		} : {
			getUserSpecifiedDiceKeyToBeShared?: () => DiceKey | undefined;
			setUserSpecifiedDiceKeyToBeShared?: (diceKey: DiceKey | undefined) => void;
		} & Partial<SimpleSecretSharingState>
  ) {
		this.getUserSpecifiedDiceKeyToBeShared = getUserSpecifiedDiceKeyToBeShared;
		this.setUserSpecifiedDiceKeyToBeShared = setUserSpecifiedDiceKeyToBeShared;
		Object.assign(this, initialSettings);
    this.navState = new NavigationPathState(parentNavState, SimpleSecretSharingStateName, () => "");
		// this.minSharesToDecode = minSharesToDecode;
		// this.numSharesToDisplay = numSharesToDisplay;
		// this.step=step;
    makeAutoObservable(this);
		this.#generate24RandomYValuesForUserSpecifiedDiceKey();
  }
}

// Should deterministic shares been generated via a pseudo-random number generator seeded by the secret?